// This file is "model.dart"
import 'dart:math';

import 'package:dart_mappable/dart_mappable.dart';

// required: associates our `models.dart` with the code generated by dart_mappable
part 'bingo_game.mapper.dart';

@MappableClass()
class BingoGame with BingoGameMappable {

  final List<int> knockCode; // for joining the game from other device
  final List<int> numbers; // randomly generated number calling order
  final int index; // current number displayed on screen
  final bool pairing; // whether trying to connect to TV
  final bool connected; // whether has successfully set up session with TV
  final int startingSeed; // seed used to generate numbers this round
  final int priority; // device with priority. 0 = main device, 1 = secondary device

  static const defaultNumberOfNumbers = 5; // allowed range of 1-390
  final int numberOfNumbers;

  late final String prev0; // current number
  late final String prev1; // previous number
  late final String prev2; // second-previous number
  static const greeting = "Let's play Bingo!";
  static const farewell = "The end!";

  /// Takes specific seed and generates specific numbers for game. Seed is important
  /// if using database syncing, as the seed is what is saved in db.
  static List<int> generateRandomList({
    int numberOfNumbers = defaultNumberOfNumbers,
    required int seed,
  })
  {
    List<int> numbers = List.generate(numberOfNumbers, (int index) => index);

    // random double algorithm
    const int a = 1664525;
    const int c = 1013904223;
    const int m = 1 << 32; // 2^32

    double nextRandomDouble() {
      seed = (a * seed + c) % m;
      return seed / m;
    }

    // randomize list using Fisher-Yates Shuffle
    int i = numbers.length;
    int j = 0;
    while (i > 0) {
      i = i - 1;
      j = (nextRandomDouble() * (i + 1)).toInt();
      int temp = numbers[j];
      numbers[j] = numbers[i];
      numbers[i] = temp;
    }

    numbers.add(-1);
    return numbers;
  }

  BingoGame({
    required this.knockCode,
    required this.numbers,
    required this.index,
    required this.pairing,
    required this.connected,
    required this.startingSeed,
    int? priority,
  }) : numberOfNumbers = numbers.length,
    priority = priority ?? 0
  {
    // set text values (primarily used for displaying)
    prev0 = (arrayHasIndex(index)) ? intToBingo(numbers[index]) : greeting;
    prev1 = (arrayHasIndex(index - 1)) ? intToBingo(numbers[index - 1]) : "";
    prev2 = (arrayHasIndex(index - 2)) ? intToBingo(numbers[index - 2]) : "";
  }

  /// if only given seed, generates specific numbers
  @MappableConstructor()
  factory BingoGame.minimal({
    required List<int> knockCode,
    List<int>? numbers,
    required int index,
    bool pairing = false,
    required bool connected,
    required int startingSeed,
    int priority = 0,
  }) {
    numbers = numbers ?? generateRandomList(seed: startingSeed);
    return BingoGame(
      knockCode: knockCode,
      numbers: numbers,
      index: index,
      pairing: pairing,
      connected: connected,
      startingSeed: startingSeed,
      priority: priority,
    );
  }

  /// creates everything from scratch, including numbers and knock codes.
  factory BingoGame.newInstance() {
    Random random = Random();
    List<int> knockCode = List.generate(8, (index) => random.nextInt(4));
    int startingSeed = random.nextInt(100);
    List<int> numbers = generateRandomList(seed: startingSeed);
    numbers.add(-1);
    return BingoGame(
      knockCode: knockCode,
      numbers: numbers,
      index: -1,
      pairing: false,
      connected: false,
      startingSeed: startingSeed,
    );
  }

  /// keeps knock code, pairing, connected, the same, but resets numbers, seed,
  /// and index.
  BingoGame resetGame() {
    Random random = Random();
    int startingSeed = random.nextInt(1 << 32);
    List<int> numbers = generateRandomList(seed: startingSeed);
    return copyWith(index: -1, numbers: numbers, startingSeed: startingSeed);
  }

  BingoGame updateIndex(int index) {
    return copyWith(index: index);
  }

  /// check if is a valid index
  bool arrayHasIndex(int index) {
    return index >= 0 && index < numbers.length;
  }

  /// check if is a valid index or -1 (meaning game not started)
  bool indexIsValid(int index) {
    return arrayHasIndex(index) || index == -1;
  }

  /// convert integer to bingo letter (e.g. 0 -> B1)
  String intToBingo(int number) {
    List<String> bingoColumns = ["B", "I", "N", "G", "O", "F", "L", "I", "C", "K", "R", "U", "S", "H", "X", "E", "P", "T", "Q", "M", "A", "D", "J", "Z", "Y", "W"];
    String newText = "";
    int range = number ~/ 15;
    newText = (number == -1) ? farewell : "${bingoColumns[range]} ${number + 1}";
    return newText;
  }

  // links deserialization factories from the generated [BingoGameMapper] class
  static final fromMap = BingoGameMapper.fromMap;
  static final fromJson = BingoGameMapper.fromJson;
}